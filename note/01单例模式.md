一、单例模式是什么？（Singleton Design Pattern）

一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。

二、单例模式可以解决的问题？

1、处理资源访问的冲突

写日志时，两个进程写到1个文件中，如果不加锁，就会相互覆盖；如果加的是对象级别的锁，那么两个线程同时往一个文件中写入，两个进程也会同时往1个文件里写入，造成相互覆盖。所以需要使用类级别的锁，就是这个对象所有的类都用1把锁，这样就会避免多个对象同时写入。

但是上面加锁的方法，实现复杂，还耗内存。单例模式同样能解决这个问题。假如把创建日志的类写成1个单例类，程序中只能创建1个日志类，这样的话所有线程在写入时，共享1个对象，就会强制顺序执行，避免了相互覆盖的问题。

2、一些数据在系统上只保存1份，也应该设计为单例类。

三、设计单例类的关注点

1. 构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；
2. 考虑对象创建时的线程安全问题；
3. 考虑是否支持延迟加载；
4. 考虑 getInstance() 性能是否高（是否加锁）。

四、几种单例类

1、饿汉式

在类加载的时候，instance 静态实例就已经创建并初始化好了。这种方式不支持延时加载，启动时候就已经初始化了。

2、懒汉式

支持延时加载，但是为了线程安全，需要在单例的全局访问接口函数上加锁。但是这会导致这个函数并发度很低，如果单例类经常使用，也就是经常访问接口函数，那么频繁加锁、释放锁等就会导致严重的性能问题。

3、双重检测

既支持延时加载，也不会带来性能问题。我们在接口函数中添加两次判空逻辑，并且在第二次判空逻辑前再加类级别的锁。

```
public class IdGenerator { 
  private AtomicLong id = new AtomicLong(0);
  private static IdGenerator instance;
  private IdGenerator() {}
  public static IdGenerator getInstance() {
    if (instance == null) {
      synchronized(IdGenerator.class) { // 此处为类级别的锁
        if (instance == null) {
          instance = new IdGenerator();
        }
      }
    }
    return instance;
  }
  public long getId() { 
    return id.incrementAndGet();
  }
}
```

先进行了第一次instance是否为空的判断，然后大家都在竞争锁，此时若一个线程拿到了锁进去创建了实力，如果里面不再进行instance判空，那么其他等待的线程等该线程释放了锁再拿到了锁还是会再进行new instance的操作，因为他们进入锁之前都是判断了instance为空。所以需要第二次instance判空，这回阻止其他已经进行第一次判空的线程重复创建instance。

指令重排序问题：instance = new IdGenerator();中，new对象后，没有进行初始化呢，相当于new后没有=，就到另一个线程了，这就会导致重复new IdGenerator()。需要在instance 成员变量加上 volatile 关键字，禁止指令重排序才行。

4、静态内部类

在单例类内创建一个静态类，这样在加载外部类时，就不会创建内部静态类的实例对象，只有再调用接口时内部类才会加载，创建了instance。

5、枚举

基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。

四、单例的缺点

1、单例对 OOP 特性的支持不友好

调用函数违背了基于接口而非实现的设计原则，调用函数提供了外部访问单例类的唯一途径，但是当我们有一天想针对不同场景使用不通的类，这就波及范围很广。

而且一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性。

2、单例会隐藏类之间的依赖关系

可读性变差：通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。

3、单例对代码的扩展性不友好

单例类在某些情况下会影响代码的扩展性、灵活性。

4、单例对代码的可测试性不友好

由于单例类可以理解为全局变量，这样就会导致mock时，修改1个值，影响后序的测试。

5、单例不支持有参数的构造函数

这个问题可以通过新增1个配置文件，然后单例类初始化时，通过配置文件初始化参数。

五、优化点

将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。

六、单例的唯一性

单例的唯一性指的是进程唯一。

1、线程唯一单例的实现

通过一个线程安全的HashMap来实现，key时线程的ID，value是对象，这样就每个线程1个对象。

2、集群环境下的单例

我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。

一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。

七、多例

“多例”指的就是，一个类可以创建多个对象，但是个数是有限制的。

①不仅1个类型可以创建多个对象；

②不同类型对应每个类型创建1个对象，也是多个对象，这样也是使用hashmap，key是类型，value是对象。







